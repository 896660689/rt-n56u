--- dropbear-2022.83/cli-main.c
+++ dropbear-2022.83/cli-main.c
@@ -88,7 +88,7 @@
 	} else
 #endif
 	{
-		progress = connect_remote(cli_opts.remotehost, cli_opts.remoteport,
+		progress = connect_remote(cli_opts.ipfamily, cli_opts.remotehost, cli_opts.remoteport,
 			cli_connected, &ses, cli_opts.bind_address, cli_opts.bind_port,
 			DROPBEAR_PRIO_LOWDELAY);
 		sock_in = sock_out = -1;
--- dropbear-2022.83/cli-runopts.c
+++ dropbear-2022.83/cli-runopts.c
@@ -56,6 +56,9 @@
 #else
 					"Usage: %s [options] [user@]host[/port] [command]\n"
 #endif
+#if defined AF_INET6 && AF_INET6 < AF_MAX
+					"-4,-6 Explicitly force IPv4 or IPv6 usage\n"
+#endif
 					"-p <remoteport>\n"
 					"-l <username>\n"
 					"-t    Allocate a pty\n"
@@ -183,10 +186,7 @@
 #ifndef DISABLE_SYSLOG
 	opts.usingsyslog = 0;
 #endif
-	/* not yet
-	opts.ipv4 = 1;
-	opts.ipv6 = 1;
-	*/
+	cli_opts.ipfamily = AF_UNSPEC;
 	opts.recv_window = DEFAULT_RECV_WINDOW;
 	opts.keepalive_secs = DEFAULT_KEEPALIVE;
 	opts.idle_timeout_secs = DEFAULT_IDLE_TIMEOUT;
@@ -217,6 +217,14 @@
 					}
 					cli_opts.always_accept_key = 1;
 					break;
+#if defined AF_INET6 && AF_INET6 < AF_MAX
+				case '4':
+					cli_opts.ipfamily = AF_INET;
+					break;
+				case '6':
+					cli_opts.ipfamily = AF_INET6;
+					break;
+#endif
 				case 'q': /* quiet */
 					cli_opts.quiet = 1;
 					break;
--- dropbear-2022.83/cli-tcpfwd.c
+++ dropbear-2022.83/cli-tcpfwd.c
@@ -273,7 +273,7 @@
 	}
 
 	snprintf(portstring, sizeof(portstring), "%u", fwd->connectport);
-	channel->conn_pending = connect_remote(fwd->connectaddr, portstring, channel_connect_done,
+	channel->conn_pending = connect_remote(AF_UNSPEC, fwd->connectaddr, portstring, channel_connect_done,
 		channel, NULL, NULL, DROPBEAR_PRIO_NORMAL);
 
 	err = SSH_OPEN_IN_PROGRESS;
--- dropbear-2022.83/netio.c
+++ dropbear-2022.83/netio.c
@@ -174,7 +174,7 @@
 }
 
 /* Connect via TCP to a host. */
-struct dropbear_progress_connection *connect_remote(const char* remotehost, const char* remoteport,
+struct dropbear_progress_connection *connect_remote(int family, 1const char* remotehost, const char* remoteport,
 	connect_callback cb, void* cb_data,
 	const char* bind_address, const char* bind_port, enum dropbear_prio prio)
 {
@@ -201,7 +201,7 @@
 
 	memset(&hints, 0, sizeof(hints));
 	hints.ai_socktype = SOCK_STREAM;
-	hints.ai_family = AF_UNSPEC;
+	hints.ai_family = family;
 
 	err = getaddrinfo(remotehost, remoteport, &hints, &c->res);
 	if (err) {
@@ -466,7 +466,7 @@
  * Returns the number of sockets bound on success, or -1 on failure. On
  * failure, if errstring wasn't NULL, it'll be a newly malloced error
  * string.*/
-int dropbear_listen(const char* address, const char* port,
+int dropbear_listen(int family, const char* address, const char* port,
 		int *socks, unsigned int sockcount, char **errstring, int *maxfd) {
 
 	struct addrinfo hints, *res = NULL, *res0 = NULL;
@@ -487,7 +487,7 @@
 #endif
 	
 	memset(&hints, 0, sizeof(hints));
-	hints.ai_family = AF_UNSPEC; /* TODO: let them flag v4 only etc */
+	hints.ai_family = family;
 	hints.ai_socktype = SOCK_STREAM;
 
 	/* for calling getaddrinfo:
--- dropbear-2022.83/netio.h
+++ dropbear-2022.83/netio.h
@@ -18,7 +18,7 @@
 		char **remote_host, char **remote_port, int host_lookup);
 void getaddrstring(struct sockaddr_storage* addr, 
 		char **ret_host, char **ret_port, int host_lookup);
-int dropbear_listen(const char* address, const char* port,
+int dropbear_listen(int family, const char* address, const char* port,
 		int *socks, unsigned int sockcount, char **errstring, int *maxfd);
 
 struct dropbear_progress_connection;
@@ -28,7 +28,7 @@
 typedef void(*connect_callback)(int result, int sock, void* data, const char* errstring);
 
 /* Always returns a progress connection, if it fails it will call the callback at a later point */
-struct dropbear_progress_connection * connect_remote (const char* remotehost, const char* remoteport,
+struct dropbear_progress_connection * connect_remote (int family, const char* remotehost, const char* remoteport,
 	connect_callback cb, void *cb_data, const char* bind_address, const char* bind_port,
 	enum dropbear_prio prio);
 
--- dropbear-2022.83/runopts.h
+++ dropbear-2022.83/runopts.h
@@ -84,11 +84,8 @@
 	   stores the childpipe preauth file descriptor. Set to -1 otherwise. */
 	int reexec_childpipe;
 
-	/* Flags indicating whether to use ipv4 and ipv6 */
-	/* not used yet
-	int ipv4;
-	int ipv6;
-	*/
+	/* ip protocol family to use */
+	int ipfamily;
 
 #if DO_MOTD
 	/* whether to print the MOTD */
@@ -147,6 +144,9 @@
 
 typedef struct cli_runopts {
 
+	/* ip protocol family to use */
+	int ipfamily;
+
 	char *progname;
 	char *remotehost;
 	const char *remoteport;
--- dropbear-2022.83/svr-main.c
+++ dropbear-2022.83/svr-main.c
@@ -143,6 +143,7 @@
 	(void)argv;
 	(void)multipath;
 
+	memset(listensocks, 0, sizeof(listensocks));
 	/* Note: commonsetup() must happen before we daemon()ise. Otherwise
 	   daemon() will chdir("/"), and we won't be able to find local-dir
 	   hostkeys. */
@@ -482,7 +483,7 @@
 
 		TRACE(("listening on '%s:%s'", svr_opts.addresses[i], svr_opts.ports[i]))
 
-		nsock = dropbear_listen(svr_opts.addresses[i], svr_opts.ports[i], &socks[sockpos], 
+		nsock = dropbear_listen(svr_opts.ipfamily, svr_opts.addresses[i], svr_opts.ports[i], &socks[sockpos], 
 				sockcount - sockpos,
 				&errstring, maxfd);
 
--- dropbear-2022.83/svr-runopts.c
+++ dropbear-2022.83/svr-runopts.c
@@ -92,6 +92,9 @@
 					"-a		Allow connections to forwarded ports from any host\n"
 					"-c command	Force executed command\n"
 #endif
+#if defined AF_INET6 && AF_INET6 < AF_MAX
+					"-4,-6		Explicitly force IPv4 or IPv6 usage\n"
+#endif
 					"-p [address:]port\n"
 					"		Listen on specified tcp port (and optionally address),\n"
 					"		up to %d can be specified\n"
@@ -185,16 +188,13 @@
 	opts.compress_mode = DROPBEAR_COMPRESS_DELAYED;
 #endif 
 
-	/* not yet
-	opts.ipv4 = 1;
-	opts.ipv6 = 1;
-	*/
 #if DO_MOTD
 	svr_opts.domotd = 1;
 #endif
 #ifndef DISABLE_SYSLOG
 	opts.usingsyslog = 1;
 #endif
+	svr_opts.ipfamily = AF_UNSPEC;
 	opts.recv_window = DEFAULT_RECV_WINDOW;
 	opts.keepalive_secs = DEFAULT_KEEPALIVE;
 	opts.idle_timeout_secs = DEFAULT_IDLE_TIMEOUT;
@@ -259,6 +259,14 @@
 					next = &reexec_fd_arg;
 					break;
 #endif
+#if defined AF_INET6 && AF_INET6 < AF_MAX
+				case '4':
+					svr_opts.ipfamily = AF_INET;
+					break;
+				case '6':
+					svr_opts.ipfamily = AF_INET6;
+					break;
+#endif
 				case 'p':
 					nextisport = 1;
 					break;
--- dropbear-2022.83/svr-tcpfwd.c
+++ dropbear-2022.83/svr-tcpfwd.c
@@ -295,7 +295,7 @@
 	}
 
 	snprintf(portstring, sizeof(portstring), "%u", destport);
-	channel->conn_pending = connect_remote(desthost, portstring, channel_connect_done,
+	channel->conn_pending = connect_remote(AF_UNSPEC, desthost, portstring, channel_connect_done,
 		channel, NULL, NULL, DROPBEAR_PRIO_NORMAL);
 
 	err = SSH_OPEN_IN_PROGRESS;
--- dropbear-2022.83/tcp-accept.c
+++ dropbear-2022.83/tcp-accept.c
@@ -116,7 +116,7 @@
 	/* first we try to bind, so don't need to do so much cleanup on failure */
 	snprintf(portstring, sizeof(portstring), "%u", tcpinfo->listenport);
 
-	nsocks = dropbear_listen(tcpinfo->listenaddr, portstring, socks, 
+	nsocks = dropbear_listen(AF_UNSPEC, tcpinfo->listenaddr, portstring, socks, 
 			DROPBEAR_MAX_SOCKS, &errstring, &ses.maxfd);
 	if (nsocks < 0) {
 		dropbear_log(LOG_INFO, "TCP forward failed: %s", errstring);
